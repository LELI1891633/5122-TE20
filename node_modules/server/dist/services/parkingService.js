import { pool } from '../config/database.js';
export class ParkingService {
    // Test database connection
    async testConnection() {
        try {
            const [rows] = await pool.execute('SELECT 1 as test');
            return { success: true, data: rows };
        }
        catch (error) {
            console.error('Database connection test failed:', error);
            return { success: false, error: error.message };
        }
    }
    // Get all available parking zones
    async getAvailableZones() {
        try {
            const [rows] = await pool.execute(`
        SELECT DISTINCT 
          z.ParkingZone as zoneNumber,
          z.OnStreet as streetName,
          z.StreetFrom,
          z.StreetTo
        FROM parking_zones_street_segments z
        ORDER BY z.ParkingZone
      `);
            return rows.map((row) => ({
                zoneNumber: row.zoneNumber,
                streetName: row.streetName,
                streetFrom: row.StreetFrom,
                streetTo: row.StreetTo
            }));
        }
        catch (error) {
            console.error('Database error:', error);
            throw new Error('Failed to fetch zones');
        }
    }
    // Get real-time parking spots data
    async getRealTimeSpots(area, hour, demand) {
        try {
            // Join parking sensors with street segments to get complete information
            const [rows] = await pool.execute(`
        SELECT 
          s.sensor_id,
          s.Zone_Number,
          s.Status_Description,
          s.Latitude,
          s.Longitude,
          s.Lastupdated_Date,
          s.Lastupdated_Time,
          z.OnStreet,
          z.StreetFrom,
          z.StreetTo
        FROM parking_bay_sensors s
        LEFT JOIN parking_zones_street_segments z 
          ON s.Zone_Number = z.ParkingZone
        WHERE s.Zone_Number = ?
        ORDER BY s.Lastupdated_Date DESC, s.Lastupdated_Time DESC
        LIMIT 100
      `, [area]);
            // Transform database rows to frontend expected format
            const spots = rows.map((row) => ({
                id: `spot-${row.sensor_id}`,
                lat: Number(row.Latitude),
                lng: Number(row.Longitude),
                occupied: this.isOccupied(row.Status_Description),
                zone: row.Zone_Number,
                street: row.OnStreet || 'Unknown Street',
                streetFrom: row.StreetFrom,
                streetTo: row.StreetTo,
                lastUpdated: `${row.Lastupdated_Date} ${row.Lastupdated_Time}`
            }));
            return {
                area,
                hour,
                demand,
                spots,
                totalSpots: spots.length,
                availableSpots: spots.filter(s => !s.occupied).length,
                occupiedSpots: spots.filter(s => s.occupied).length
            };
        }
        catch (error) {
            console.error('Database error:', error);
            throw new Error('Failed to fetch parking spots');
        }
    }
    // Get parking zone statistics
    async getZoneStats() {
        try {
            const [rows] = await pool.execute(`
        SELECT 
          s.Zone_Number,
          COUNT(*) as total_sensors,
          SUM(CASE WHEN s.Status_Description = 'Present' THEN 1 ELSE 0 END) as occupied_count,
          z.OnStreet as street_name
        FROM parking_bay_sensors s
        LEFT JOIN parking_zones_street_segments z ON s.Zone_Number = z.ParkingZone
        GROUP BY s.Zone_Number, z.OnStreet
        ORDER BY s.Zone_Number
      `);
            return rows;
        }
        catch (error) {
            console.error('Database error:', error);
            throw new Error('Failed to fetch zone stats');
        }
    }
    // Determine if parking spot is occupied based on status description
    isOccupied(statusDescription) {
        if (!statusDescription)
            return false;
        // Based on actual database values: 'Present' = occupied, 'Unoccupied' = available
        return statusDescription === 'Present';
    }
}
//# sourceMappingURL=parkingService.js.map
<template>
  <div class="hero">
    <div class="hero-inner">
      <h1>Real-Time Parking</h1>
    </div>
  </div>

  <div class="rt-container">
    <!-- Left panel: interactive map inside black board -->
    <section class="board">
      <p class="board-title">Live map visualisation of Real-Time availability</p>
      <div class="illustration">
        <div ref="mapEl" class="map-layer"></div>
      </div>
      <p class="board-sub">
        View available spots in real-time by time of day, area and current demand
      </p>
      <div class="board-actions">
        <button class="btn-outline" @click="onRefresh">Refresh Spots</button>
        <button class="btn-outline" @click="onLocate">Detect my location</button>
      </div>
      <div v-if="errorMsg" class="board-error">{{ errorMsg }}</div>
    </section>

    <!-- Right side filter -->
    <aside class="filter">
      <h2>Select Area</h2>
      <select class="select" v-model="area">
        <option>Melbourne CBD</option>
        <option>Docklands</option>
        <option>Southbank</option>
      </select>

      <h3>Time of Day</h3>
      <input class="range" type="range" min="0" max="23" v-model.number="hour" />

      <h3>Demand Level</h3>
      <div class="btn-group">
        <button class="chip" :class="{active: demand==='High'}" @click="setDemand('High')">High</button>
        <button class="chip" :class="{active: demand==='Medium'}" @click="setDemand('Medium')">Medium</button>
        <button class="chip" :class="{active: demand==='Low'}" @click="setDemand('Low')">Low</button>
      </div>

      <button class="btn-primary" @click="onSearch">Search Now</button>

      <h3>Parking Timer</h3>
      <div class="timer">
        <div class="timer-options">
          <button
            v-for="m in timerOptions"
            :key="m"
            class="timer-pill"
            :class="{ active: selectedMinutes===m }"
            @click="selectedMinutes = m"
          >{{ m }} min</button>
        </div>
        <div class="timer-actions">
          <button class="btn-primary" @click="onStartTimer">Start Timer</button>
          <button class="btn-outline" @click="onResetTimer" :disabled="!timerActive">Reset</button>
        </div>
        <div v-if="timerActive" class="timer-display">Remaining: {{ remainingText }}</div>
      </div>
    </aside>
  </div>
</template>

<script setup lang="ts">
import { nextTick, onMounted, onUnmounted, ref } from 'vue'
import L from 'leaflet'
import 'leaflet/dist/leaflet.css'

type Demand = 'High'|'Medium'|'Low'
const area   = ref<'Melbourne CBD'|'Docklands'|'Southbank'>('Melbourne CBD')
const hour   = ref<number>(12)
const demand = ref<Demand>('Medium')
const errorMsg = ref('')

async function onSearch(){
  errorMsg.value = ''
  await loadSpots()
}
async function onRefresh(){ await loadSpots() }
function onLocate(){ map?.locate({ setView:true, maxZoom:15 }) }
function setDemand(d: Demand){ demand.value = d; loadSpots() }

// Map container ref and lifecycle
const mapEl = ref<HTMLDivElement|null>(null)
let map: L.Map | null = null
let ro: ResizeObserver | null = null
let layerGroup: L.LayerGroup | null = null

onMounted(async () => {
  await nextTick()
  if (!mapEl.value) return
  map = L.map(mapEl.value, { zoomControl: true, scrollWheelZoom: true })
    .setView([-37.8136, 144.9631], 13)
  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    attribution: '&copy; OpenStreetMap',
    detectRetina: true
  }).addTo(map)
  layerGroup = L.layerGroup().addTo(map)
  // Double refresh to avoid tile glitches on first paint
  requestAnimationFrame(() => {
    map!.invalidateSize()
    requestAnimationFrame(() => map!.invalidateSize())
  })

  // Refresh map size when container/window changes
  ro = new ResizeObserver(() => map?.invalidateSize())
  ro.observe(mapEl.value)
  window.addEventListener('resize', handleResize)
})

onUnmounted(() => {
  window.removeEventListener('resize', handleResize)
  ro?.disconnect(); ro = null
})

function handleResize(){
  // Light debounce
  setTimeout(() => map?.invalidateSize(), 80)
}

type SpotsResp = { area: string; hour: number; demand: Demand; spots: { id:string; lat:number; lng:number; occupied:boolean }[] }
async function loadSpots(){
  try{
    if (!map) return
    const params = new URLSearchParams({ area: area.value, hour: String(hour.value), demand: demand.value })
    const res = await fetch(`/api/realtime/spots?${params.toString()}`)
    if (!res.ok) throw new Error(`API ${res.status}`)
    const data = await res.json() as SpotsResp
    renderSpots(data.spots)
  }catch(e:any){
    errorMsg.value = e?.message ?? 'Failed to load spots'
  }
}

function renderSpots(spots: { id:string; lat:number; lng:number; occupied:boolean }[]){
  if (!map || !layerGroup) return
  layerGroup.clearLayers()
  for (const s of spots){
    const marker = L.circleMarker([s.lat, s.lng], {
      radius: 6,
      color: s.occupied ? '#e74c3c' : '#2ecc71',
      weight: 1,
      fillOpacity: 0.9
    })
    marker.bindTooltip(s.occupied ? 'Occupied' : 'Available')
    marker.addTo(layerGroup)
  }
}

// Parking Timer (minimal, no extra files)
const timerOptions = [30, 60, 120, 180]
const selectedMinutes = ref<number>(30)
const timerActive = ref(false)
const endAt = ref<number|null>(null)
const remainingText = ref('00:00')
let timerHandle: number | null = null

function onStartTimer(){
  const mins = selectedMinutes.value || 30
  endAt.value = Date.now() + mins * 60_000
  timerActive.value = true
  tick()
  if (timerHandle) window.clearInterval(timerHandle)
  timerHandle = window.setInterval(tick, 250)
  ensureNotifyPermission()
}

function onResetTimer(){
  if (timerHandle) { window.clearInterval(timerHandle); timerHandle = null }
  timerActive.value = false
  endAt.value = null
  remainingText.value = '00:00'
}

function tick(){
  if (!endAt.value) return
  const ms = Math.max(0, endAt.value - Date.now())
  remainingText.value = formatDuration(ms)
  if (ms === 0){
    if (timerHandle) { window.clearInterval(timerHandle); timerHandle = null }
    timerActive.value = false
    notify('Parking timer', 'Time is up. Please return to your car.')
  }
}

function formatDuration(ms: number): string{
  const total = Math.floor(ms / 1000)
  const h = Math.floor(total / 3600)
  const m = Math.floor((total % 3600) / 60)
  const s = total % 60
  const mm = String(m).padStart(2,'0')
  const ss = String(s).padStart(2,'0')
  return h > 0 ? `${h}:${mm}:${ss}` : `${mm}:${ss}`
}

function ensureNotifyPermission(){
  if ('Notification' in window && Notification.permission === 'default'){
    Notification.requestPermission().catch(()=>{})
  }
}

function notify(title: string, body: string){
  if (!('Notification' in window)) return
  if (Notification.permission === 'granted'){
    new Notification(title, { body })
  }
}
</script>

<style scoped>
/* Top banner */
.hero { background: linear-gradient(135deg, #9196fc, #8f94fb); }
.hero-inner { max-width:1100px; margin:0 auto; padding:40px 16px 24px; text-align:center; }
.hero h1 { font-size:42px; font-weight:900; margin:0; color:#fff; } /* Changed to white text on light purple background */

/* Two-column layout */
.rt-container {
  max-width:1100px; margin:0 auto; padding:24px 16px 60px;
  display:grid; grid-template-columns: 1fr 360px; gap:24px;
}

/* Left board - matching Home page style */
.board {
  background:#f9f9ff; color:#4e54c8; border:1px solid #e5e5e5; border-radius:12px;
  padding:18px 18px 24px; display:flex; flex-direction:column; align-items:center;
  box-shadow: 0 4px 10px rgba(0,0,0,0.05);
}
.board-title { margin:6px 0 16px; font-weight:700; opacity:.95; color:#4e54c8; }

/* Map board */
.illustration{
  width:100%; height:clamp(380px, 56vh, 640px);
  border-radius:4px; border:1px solid #333; background:#0e0e0e;
  position:relative; /* Provides positioning context for absolutely positioned map and overlay */
  display:flex; align-items:center; justify-content:center;
}
.map-layer{ position:absolute; inset:0; z-index:2; border-radius:4px; overflow:hidden; }

/* Leaflet adjustments: fill container and avoid image scaling issues */
.map-layer :deep(.leaflet-container){ width:100%; height:100%; background:transparent; }
.map-layer :deep(img){ max-width:none !important; }

.board-sub { margin:14px 0 10px; color:#4e54c8; opacity:0.8; font-size:14px; text-align:center; }
.board-actions { display:flex; gap:18px; position:relative; z-index:1; }
.btn-outline{
  appearance:none; background:#fff; color:#4e54c8; border:1px solid #d8d8d8;
  padding:8px 16px; border-radius:4px; cursor:pointer;
}
.board-error{
  color:#ff6b6b; font-size:14px; margin-top:10px; text-align:center;
}

/* Right filter card - matching Home page style */
.filter{
  background:#f9f9ff; color:#4e54c8; border:1px solid #e5e5e5; border-radius:12px; padding:22px 20px; height:fit-content;
  box-shadow: 0 4px 10px rgba(0,0,0,0.05);
}
.filter h2{ font-size:24px; margin:0 0 12px; font-weight:800; color:#4e54c8; }
.filter h3{ margin:18px 0 8px; font-size:16px; font-weight:800; color:#4e54c8; }
.select{
  width:100%; padding:8px 10px; border-radius:4px; border:1px solid #d8d8d8; background:#fff; color:#4e54c8;
}
.range{ width:100%; accent-color:#7b6bd6; }

.btn-group{ display:flex; gap:12px; margin-bottom:18px; }
.chip{
  background:#fff; color:#4e54c8; border:1px solid #d8d8d8; padding:6px 12px; border-radius:4px; cursor:pointer;
}
.chip.active{ background:#4e54c8; color:#fff; border-color:#4e54c8; }
.btn-primary{
  width:100%; background:#fff; color:#4e54c8; border:1px solid #d8d8d8; padding:10px 0; border-radius:4px; cursor:pointer;
}
.timer{ margin-top:12px; padding-top:8px; border-top:1px solid #e5e5e5; }
.timer-options{ display:flex; flex-direction:column; gap:8px; margin-bottom:10px; }
.timer-pill{ width:100%; background:#fff; color:#4e54c8; border:1px solid #d8d8d8; padding:8px 10px; border-radius:4px; cursor:pointer; text-align:left; }
.timer-pill.active{ border-color:#7b6bd6; box-shadow:0 0 0 2px rgba(123,107,214,.25) inset; color:#4e54c8; }
.timer-actions{ display:flex; gap:10px; }
.timer-display{ margin-top:8px; font-size:14px; opacity:.9; color:#4e54c8; }
/* Responsive */
@media (max-width: 992px){
  .rt-container{ grid-template-columns: 1fr; }
}
</style>
